
<html><head><base href="https://websim.ai/"><title>Рейтинг Дупла</title>
<style>
  body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    max-width: 1000px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f4f4f4;
  }
  h1, h2 {
    color: #2c3e50;
    text-align: center;
  }
  .container {
    background-color: #fff;
    border-radius: 5px;
    padding: 20px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }
  #rawResponseData {
    display: none;
  }
  #lastUpdated {
    text-align: center;
    font-style: italic;
    margin-top: 10px;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
  }
  th, td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
    font-size: 14px;
  }
  th {
    background-color: #f2f2f2;
    font-weight: bold;
  }
  tr:nth-child(even) {
    background-color: #f9f9f9;
  }
  .level-info {
    text-align: center;
    margin-bottom: 20px;
  }
  .level {
    font-size: 48px;
    font-weight: bold;
    color: #3498db;
  }
  .progress-bar {
    background-color: #e0e0e0;
    height: 30px;
    border-radius: 15px;
    margin-top: 10px;
    overflow: hidden;
  }
  .progress {
    background-color: #3498db;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    transition: width 0.5s ease-in-out;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Рейтинг Дупла</h1>
    
    <div class="level-info">
      <div id="sumData">Загрузка данных...</div>
      <div class="level">Уровень: <span id="currentLevel">-</span></div>
      <div id="nextLevelInfo"></div>
      <div class="progress-bar">
        <div id="progressBar" class="progress"></div>
      </div>
    </div>
    
    <div id="rawResponseData" style="display: none;"></div>
    
    <div class="response-container">
      <table id="dataTable">
        <thead>
          <tr>
            <th>№</th>
            <th>Кошелек</th>
            <th>Darai (с учетом буста)</th>
            <th>Буст</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>

    <p id="lastUpdated"></p>
  </div>

  <script>
    const blacklist = [
      "darai_drop.near",
      "kaylani_vibe.tg",
      "miplix.tg",
      "flatrat3656.near",
      "alla_moons.tg"
    ];

    const aggregationPairs = {
      "right_run-hot2.tg": ["alexsun1331.tg", "right_run-hot2.tg"],
      "tightdove659.near": ["alexn_450.tg", "tightdove659.near"]
    };

    const query1 = `
      query {
        mb_views_nft_tokens(
          where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, owner: {_gt: "darai_collection.near"}, title: {_iregex: "Super Dupla generator"}}
        ) {
          owner
          title
        }
      }
    `;

    const query2 = `
      query {
        mb_views_nft_tokens(
          where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_iregex: "Hollow Upgrade Scroll"}}
        ) {
          owner
          title
        }
      }
    `;

    const query3 = `
      query {
        mb_views_nft_tokens(
          where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_iregex: "DarAi Generator"}}
        ) {
          owner
          title
        }
      }
    `;

    const query4 = `
      query {
        mb_views_nft_tokens(
          where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_iregex: "Fate Generator"}}
        ) {
          owner
          title
        }
      }
    `;

    const query5 = `
      query {
        mb_views_nft_tokens(
          where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (useless)"}}
        ) {
          owner
          title
        }
      }
    `;

    const query6 = `
      query {
        mb_views_nft_tokens(
          where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (update +1)"}}
        ) {
          owner
          title
        }
      }
    `;
    
    const query7 = `
      query {
        mb_views_nft_tokens(
          where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (update +2)"}}
        ) {
          owner
          title
        }
      }
    `;
    
    const query8 = `
      query {
        mb_views_nft_tokens(
          where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (update +3)"}}
        ) {
          owner
          title
        }
      }
    `;
    
    const query9 = `
      query {
        mb_views_nft_tokens(
          where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (update +4)"}}
        ) {
          owner
          title
        }
      }
    `;
    
    const totalResults = {};

    async function fetchNFTData(query, percentageMultiplier) {
      try {
        const response = await axios.post('https://graph.mintbase.xyz/mainnet', { query }, {
          headers: {
            'Content-Type': 'application/json',
            'mb-api-key': 'anon'
          }
        });

        const data = response.data.data.mb_views_nft_tokens;
        const ownerCounts = {};

        data.forEach(item => {
          if (ownerCounts[item.owner]) {
            ownerCounts[item.owner]++;
          } else {
            ownerCounts[item.owner] = 1;
          }

          if (!totalResults[item.owner]) {
            totalResults[item.owner] = 0;
          }
          totalResults[item.owner] += percentageMultiplier;
        });

        return ownerCounts;
      } catch (error) {
        console.error('Error fetching NFT data:', error);
        return {};
      }
    }

    async function fetchAllNFTData() {
      const results = await Promise.all([
        fetchNFTData(query1, 50),
        fetchNFTData(query2, 20),
        fetchNFTData(query3, 10),
        fetchNFTData(query4, 500),
        fetchNFTData(query5, 2),
        fetchNFTData(query6, 40),
        fetchNFTData(query7, 80),
        fetchNFTData(query8, 160),
        fetchNFTData(query9, 320)
      ]);

      const combinedResults = {};
      results.forEach(result => {
        for (const [owner, percentage] of Object.entries(result)) {
          if (!combinedResults[owner]) {
            combinedResults[owner] = 0;
          }
          combinedResults[owner] += percentage;
        }
      });

      return combinedResults;
    }

    function fetchAndAnalyzeData() {
      const url = 'https://api.pikespeak.ai/account/incoming-token/darai_duplo.near';
      const headers = new Headers({
        'accept': 'application/json',
        'x-api-key': '30ee49e1-f45e-4de0-ba7e-e01d6cecd484'
      });

      fetch(url, { method: 'GET', headers: headers })
        .then(response => response.json())
        .then(async data => {
          document.getElementById('rawResponseData').textContent = JSON.stringify(data, null, 2);

          const filteredData = data.filter(item => 
            item.contract === "darai.tkn.near" && !blacklist.includes(item.sender)
          );

          let aggregatedData = {};
          let usedSenders = new Set();

          for (let [aggregatedSender, senders] of Object.entries(aggregationPairs)) {
            let totalAmount = 0;
            senders.forEach(sender => {
              let item = filteredData.find(i => i.sender === sender);
              if (item) {
                totalAmount += parseFloat(item.amount);
                usedSenders.add(sender);
              }
            });
            if (totalAmount > 0) {
              aggregatedData[aggregatedSender] = totalAmount;
            }
          }

          filteredData.forEach(item => {
            if (!usedSenders.has(item.sender)) {
              aggregatedData[item.sender] = parseFloat(item.amount);
            }
          });

          const nftBoostData = await fetchAllNFTData();

          let sortedData = Object.entries(aggregatedData)
            .map(([sender, amount]) => {
              const boost = nftBoostData[sender] || 0;
              const boostedAmount = amount * (1 + boost / 100);
              return [sender, boostedAmount, boost];
            })
            .sort((a, b) => b[1] - a[1]);

          const tableBody = document.getElementById('tableBody');
          tableBody.innerHTML = '';

          sortedData.forEach((item, index) => {
            const [sender, boostedAmount, boost] = item;
            const row = tableBody.insertRow();
            row.insertCell(0).textContent = index + 1;
            row.insertCell(1).textContent = sender;
            row.insertCell(2).textContent = Math.round(boostedAmount).toLocaleString('ru-RU');
            row.insertCell(3).textContent = boost ? `+${boost}%` : '0%';
          });

          const now = new Date();
          document.getElementById('lastUpdated').textContent = `Last updated: ${now.toLocaleString()}`;
        })
        .catch(error => {
          document.getElementById('tableBody').innerHTML = '<tr><td colspan="4">Error: ' + error.message + '</td></tr>';
        });
    }

    const API_KEY = '82DCA141CBC949B89A07F651AE64E917';
    const RAW_DATA_URL = 'https://api.nearblocks.io/v1/fts/darai.tkn.near/holders?page=1&per_page=25';
    const WHITELIST_KEYWORD = 'darai_duplo.near';

    const levels = [
      { level: 1, threshold: 1_000_000 },
      { level: 2, threshold: 10_000_000 },
      { level: 3, threshold: 50_000_000 },
      { level: 4, threshold: 100_000_000 },
      { level: 5, threshold: 200_000_000 },
      { level: 6, threshold: 400_000_000 },
      { level: 7, threshold: 800_000_000 },
      { level: 8, threshold: 1_500_000_000 },
      { level: 9, threshold: 3_000_000_000 }
    ];

    async function fetchData() {
      try {
        const response = await fetch(RAW_DATA_URL, {
          method: 'GET',
          headers: {
            'Authorization': 'Bearer ' + API_KEY
          }
        });
        if (!response.ok) {
          throw new Error('Ошибка сети: ' + response.status);
        }
        const data = await response.json();
        displaySumData(data);
      } catch (error) {
        document.getElementById('sumData').innerText = `Ошибка: ${error.message}`;
      }
    }

    function displaySumData(data) {
      const sumElement = document.getElementById('sumData');
      if (data && data.holders && data.holders.length > 0) {
        const filtered = data.holders.filter(holder => holder.account === WHITELIST_KEYWORD);
        if (filtered.length > 0) {
          const total = filtered.reduce((acc, holder) => acc + Number(holder.amount), 0);
          const formattedTotal = (total / 1e18).toLocaleString('ru-RU', {minimumFractionDigits: 0, maximumFractionDigits: 6});
          sumElement.innerText = `Сумма: ${formattedTotal}`;
          updateLevelInfo(total / 1e18);
        } else {
          sumElement.innerText = 'Совпадений не найдено.';
        }
      } else {
        sumElement.innerText = 'Данные не найдены.';
      }
    }

    function updateLevelInfo(totalAmount) {
      let currentLevel = 0;
      let nextLevelThreshold = 0;

      for (let i = 0; i < levels.length; i++) {
        if (totalAmount >= levels[i].threshold) {
          currentLevel = levels[i].level;
        } else {
          nextLevelThreshold = levels[i].threshold;
          break;
        }
      }

      document.getElementById('currentLevel').textContent = currentLevel;

      if (currentLevel < 9) {
        const remainingForNextLevel = nextLevelThreshold - totalAmount;
        document.getElementById('nextLevelInfo').textContent = `До следующего уровня: ${remainingForNextLevel.toLocaleString('ru-RU', {minimumFractionDigits: 0, maximumFractionDigits: 0})}`;
        
        const progressPercentage = (totalAmount / nextLevelThreshold) * 100;
        const progressBar = document.getElementById('progressBar');
        progressBar.style.width = `${progressPercentage}%`;
        progressBar.textContent = `${progressPercentage.toFixed(2)}%`;
      } else {
        document.getElementById('nextLevelInfo').textContent = 'Максимальный уровень достигнут!';
        document.getElementById('progressBar').style.width = '100%';
        document.getElementById('progressBar').textContent = '100%';
      }
    }

    window.onload = () => {
      fetchData();
      fetchAndAnalyzeData();
    };
  </script>
</body></html>
