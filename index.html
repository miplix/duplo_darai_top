
<html><head><base href="https://websim.ai/"><title>Рейтинг Дупла</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<style>
  body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    max-width: 100%;
    margin: 0 auto;
    padding: 10px;
    background-color: #f4f4f4;
  }
  h1 {
    color: #000;
    text-align: center;
    font-size: 22px;
  }
  .container {
    background-color: #fff;
    border-radius: 5px;
    padding: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }
  #sumData, #levelInfo, #nextLevelInfo {
    color: #000;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
  }
  th, td {
    border: 1px solid #ddd;
    padding: 6px;
    text-align: left;
    font-size: 11px;
    word-break: break-word;
  }
  th {
    background-color: #f2f2f2;
    font-weight: bold;
  }
  tr:nth-child(even) {
    background-color: #f9f9f9;
  }
  #sumData {
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    margin: 20px 0;
  }
  #progressContainer {
    width: 100%;
    background-color: #e0e0e0;
    margin-top: 10px;
    border-radius: 5px;
    overflow: hidden;
  }
  #progressBar {
    width: 0;
    height: 20px;
    background-color: #ADD8E6;
    text-align: center;
    line-height: 20px;
    color: black;
    transition: width 0.5s ease-in-out;
  }
  #levelInfo {
    text-align: center;
    font-size: 24px;
    font-weight: bold;
    margin: 10px 0;
  }
  #nextLevelInfo {
    text-align: center;
    font-size: 16px;
    margin: 10px 0;
  }
</style>
</head>
<body>
  <div class="container">
    <h1>Рейтинг Дупла</h1>
    
    <div id="sumData"></div>
    <div id="levelInfo"></div>
    <div id="nextLevelInfo"></div>
    <div id="progressContainer">
      <div id="progressBar"></div>
    </div>
    
    <div id="rawResponseData" style="display: none;"></div>
    
    <div class="response-container">
      <table id="dataTable">
        <thead>
          <tr>
            <th>№</th>
            <th>Кошелек</th>
            <th>Darai</th>
            <th>Буст</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>

    <p id="lastUpdated"></p>
  </div>

  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <script>
    const blacklist = [
      "darai_drop.near",
      "kaylani_vibe.tg",
      "miplix.tg",
      "flatrat3656.near",
      "alla_moons.tg"
    ];

    const aggregationPairs = {
      "alexsun1331.tg": ["alexsun1331.tg", "right_run-hot2.tg"],
      "tightdove659.near": ["alexn_450.tg", "tightdove659.near"]
    };

    const queries = [
      {
        query: `
          query {
            mb_views_nft_tokens(
              where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, owner: {_gt: "darai_collection.near"}, title: {_iregex: "Super Dupla generator"}}
            ) {
              owner
              title
            }
          }
        `,
        resultId: 'result1',
        percentageMultiplier: 50
      },
      {
        query: `
          query {
            mb_views_nft_tokens(
              where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_iregex: "Hollow Upgrade Scroll"}}
            ) {
              owner
              title
            }
          }
        `,
        resultId: 'result2',
        percentageMultiplier: 20
      },
      {
        query: `
          query {
            mb_views_nft_tokens(
              where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_iregex: "DarAi Generator"}}
            ) {
              owner
              title
            }
          }
        `,
        resultId: 'result3',
        percentageMultiplier: 10
      },
      {
        query: `
          query {
            mb_views_nft_tokens(
              where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_iregex: "Fate Generator"}}
            ) {
              owner
              title
            }
          }
        `,
        resultId: 'result4',
        percentageMultiplier: 500
      },
      {
        query: `
          query {
            mb_views_nft_tokens(
              where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (useless)"}}
            ) {
              owner
              title
            }
          }
        `,
        resultId: 'result5',
        percentageMultiplier: 2
      },
      {
        query: `
          query {
            mb_views_nft_tokens(
              where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (update +1)"}}
            ) {
              owner
              title
            }
          }
        `,
        resultId: 'result6',
        percentageMultiplier: 40
      },
      {
        query: `
          query {
            mb_views_nft_tokens(
              where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (update +2)"}}
            ) {
              owner
              title
            }
          }
        `,
        resultId: 'result7',
        percentageMultiplier: 80
      },
      {
        query: `
          query {
            mb_views_nft_tokens(
              where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (update +3)"}}
            ) {
              owner
              title
            }
          }
        `,
        resultId: 'result8',
        percentageMultiplier: 160
      },
      {
        query: `
          query {
            mb_views_nft_tokens(
              where: {nft_contract_id: {_eq: "yuplandshop.mintbase1.near"}, title: {_eq: "Old motor (update +4)"}}
            ) {
              owner
              title
            }
          }
        `,
        resultId: 'result9',
        percentageMultiplier: 320
      }
    ];

    const globalOwnerCounts = {};

    async function fetchBoostData() {
      for (const queryObj of queries) {
        try {
          const response = await axios.post('https://graph.mintbase.xyz/mainnet', { query: queryObj.query }, {
            headers: {
              'Content-Type': 'application/json',
              'mb-api-key': 'anon'
            }
          });

          const data = response.data.data.mb_views_nft_tokens;
          data.forEach(item => {
            if (globalOwnerCounts[item.owner]) {
              globalOwnerCounts[item.owner] += queryObj.percentageMultiplier;
            } else {
              globalOwnerCounts[item.owner] = queryObj.percentageMultiplier;
            }
          });
        } catch (error) {
          console.error('Error fetching boost data:', error);
        }
      }
    }

    function formatNumber(num) {
      return num.toLocaleString('en-US').replace(/,/g, ' ');
    }

    function updateTableStyles() {
      const rows = document.querySelectorAll('#tableBody tr');
      rows.forEach((row, index) => {
        if (index < 3) {
          row.style.backgroundColor = '#fff7d6';
        } else if (index < 10) {
          row.style.backgroundColor = 'e6ffd0';
        } else if (index < 30) {
          row.style.backgroundColor = '#f4f4f4';
        }
      });
    }

    function fetchAndAnalyzeData() {
      const url = 'https://api.pikespeak.ai/account/incoming-token/darai_duplo.near';
      const headers = new Headers({
        'accept': 'application/json',
        'x-api-key': '30ee49e1-f45e-4de0-ba7e-e01d6cecd484'
      });

      fetch(url, { method: 'GET', headers: headers })
        .then(response => response.json())
        .then(async data => {
          document.getElementById('rawResponseData').textContent = JSON.stringify(data, null, 2);

          const filteredData = data.filter(item => 
            item.contract === "darai.tkn.near" && !blacklist.includes(item.sender)
          );

          let aggregatedData = {};
          let usedSenders = new Set();

          for (let [aggregatedSender, senders] of Object.entries(aggregationPairs)) {
            let totalAmount = 0;
            senders.forEach(sender => {
              let item = filteredData.find(i => i.sender === sender);
              if (item) {
                totalAmount += parseFloat(item.amount);
                usedSenders.add(sender);
              }
            });
            if (totalAmount > 0) {
              aggregatedData[aggregatedSender] = totalAmount;
            }
          }

          filteredData.forEach(item => {
            if (!usedSenders.has(item.sender)) {
              aggregatedData[item.sender] = parseFloat(item.amount);
            }
          });

          await fetchBoostData();

          let sortedData = Object.entries(aggregatedData)
            .map(([sender, amount]) => {
              const boost = globalOwnerCounts[sender] || 0;
              const boostedAmount = amount * (1 + boost / 100);
              return { sender, amount: boostedAmount, boost };
            })
            .sort((a, b) => b.amount - a.amount);

          const tableBody = document.getElementById('tableBody');
          tableBody.innerHTML = '';

          sortedData.forEach((item, index) => {
            const row = tableBody.insertRow();
            row.insertCell(0).textContent = index + 1;
            row.insertCell(1).textContent = item.sender;
            row.insertCell(2).textContent = formatNumber(Math.round(item.amount));
            row.insertCell(3).textContent = `+${item.boost}%`;
          });

          updateTableStyles();

          const now = new Date();
          document.getElementById('lastUpdated').textContent = `Last updated: ${now.toLocaleString()}`;
        })
        .catch(error => {
          document.getElementById('tableBody').innerHTML = '<tr><td colspan="4">Error: ' + error.message + '</td></tr>';
        });
    }

    const API_KEY = '82DCA141CBC949B89A07F651AE64E917';
    const RAW_DATA_URL = 'https://api.nearblocks.io/v1/fts/darai.tkn.near/holders?page=1&per_page=25';
    const WHITELIST_KEYWORD = 'darai_duplo.near';

    const levels = [
      { level: 1, threshold: 1000000 },
      { level: 2, threshold: 10000000 },
      { level: 3, threshold: 50000000 },
      { level: 4, threshold: 100000000 },
      { level: 5, threshold: 200000000 },
      { level: 6, threshold: 400000000 },
      { level: 7, threshold: 800000000 },
      { level: 8, threshold: 1500000000 },
      { level: 9, threshold: 3000000000 }
    ];

    async function fetchData() {
      try {
        const response = await fetch(RAW_DATA_URL, {
          method: 'GET',
          headers: {
            'Authorization': 'Bearer ' + API_KEY
          }
        });
        if (!response.ok) {
          throw new Error('Ошибка сети: ' + response.status);
        }
        const data = await response.json();
        displaySumData(data);
      } catch (error) {
        document.getElementById('sumData').innerText = `Ошибка: ${error.message}`;
      }
    }

    function displaySumData(data) {
      const sumElement = document.getElementById('sumData');
      const levelInfoElement = document.getElementById('levelInfo');
      const nextLevelInfoElement = document.getElementById('nextLevelInfo');
      const progressBar = document.getElementById('progressBar');

      if (data && data.holders && data.holders.length > 0) {
        const filtered = data.holders.filter(holder => holder.account === WHITELIST_KEYWORD);
        if (filtered.length > 0) {
          const total = filtered.reduce((acc, holder) => acc + Number(holder.amount), 0);
          const formattedTotal = Math.round(total / 1e18).toLocaleString('ru-RU');
          sumElement.innerText = `Сумма: ${formattedTotal} DarAi`;

          const currentAmount = total / 1e18;
          let currentLevel = 0;
          let nextLevelThreshold = 0;
          for (let i = 0; i < levels.length; i++) {
            if (currentAmount >= levels[i].threshold) {
              currentLevel = levels[i].level;
            } else {
              nextLevelThreshold = levels[i].threshold;
              break;
            }
          }

          levelInfoElement.innerText = `УРОВЕНЬ ДУПЛА: ${currentLevel}`;

          if (currentLevel < 9) {
            const amountForNextLevel = nextLevelThreshold - currentAmount;
            nextLevelInfoElement.innerText = `До следующего уровня: ${Math.round(amountForNextLevel).toLocaleString('ru-RU')} DarAi`;

            const progressPercentage = (currentAmount / nextLevelThreshold) * 100;
            progressBar.style.width = `${progressPercentage}%`;
            progressBar.innerText = `${progressPercentage.toFixed(2)}%`;
          } else {
            nextLevelInfoElement.innerText = 'Максимальный уровень достигнут!';
            progressBar.style.width = '100%';
            progressBar.innerText = '100%';
          }
        } else {
          sumElement.innerText = 'Совпадений не найдено.';
        }
      } else {
        sumElement.innerText = 'Данные не найдены.';
      }
    }

    window.addEventListener('load', () => {
      fetchAndAnalyzeData();
      fetchData();
    });
  </script>
</body></html>
